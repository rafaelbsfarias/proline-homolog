# Plano de Refatora√ß√£o - Contexto do Parceiro

**Data:** 2025-10-09  
**Branch Base:** `aprovacao-orcamento-pelo-admin`  
**Objetivo:** Refatorar contexto do parceiro seguindo princ√≠pios DRY, SOLID e Arquitetura Modular

---

## üéØ Estrat√©gia Geral

### Abordagem: Refatora√ß√£o Gradual e Segura

1. **N√£o quebrar produ√ß√£o** - Manter retrocompatibilidade
2. **Testar incrementalmente** - Cada mudan√ßa deve ser test√°vel
3. **Commits at√¥micos** - Cada commit deve ser independente
4. **Documentar mudan√ßas** - Atualizar documenta√ß√£o conforme avan√ßamos

### Fases do Plano

- **Fase 1:** Corre√ß√µes Cr√≠ticas de Seguran√ßa (P0)
- **Fase 2:** Padroniza√ß√£o de Infraestrutura (P1)
- **Fase 3:** Refatora√ß√£o de Arquitetura (P2)
- **Fase 4:** Melhorias de Qualidade (P3)

---

## üìÖ Fase 1: Corre√ß√µes Cr√≠ticas de Seguran√ßa (P0)

**Dura√ß√£o Estimada:** 2-3 horas  
**Branch:** `refactor/partner-security-fixes`

### 1.1 Adicionar Autentica√ß√£o em Endpoints Desprotegidos

**Arquivos Afetados:**
- ‚ùå `app/api/partner/checklist/load/route.ts`
- ‚ùå `app/api/partner/checklist/load-anomalies/route.ts`
- ‚ùå `app/api/partner/checklist/exists/route.ts`
- ‚ùå `app/api/partner/get-vehicle-from-inspection/route.ts`

**A√ß√µes:**
```typescript
// ANTES
export async function POST(request: Request) {
  const body = await request.json();
  // ... l√≥gica sem autentica√ß√£o
}

// DEPOIS
import { withPartnerAuth, type AuthenticatedRequest } from '@/modules/common/utils/authMiddleware';

async function loadChecklistHandler(req: AuthenticatedRequest) {
  const body = await req.json();
  // ... l√≥gica com req.user.id dispon√≠vel
}

export const POST = withPartnerAuth(loadChecklistHandler);
```

**Checklist:**
- [ ] Adicionar `withPartnerAuth` em `checklist/load/route.ts`
- [ ] Adicionar `withPartnerAuth` em `checklist/load-anomalies/route.ts`
- [ ] Adicionar `withPartnerAuth` em `checklist/exists/route.ts`
- [ ] Adicionar `withPartnerAuth` em `get-vehicle-from-inspection/route.ts`
- [ ] Testar cada endpoint com token v√°lido
- [ ] Testar cada endpoint sem token (deve retornar 401)
- [ ] Atualizar testes automatizados

---

### 1.2 Remover Hardcoded Credentials

**Arquivo Cr√≠tico:**
- üî¥ `app/api/partner/checklist/exists/route.ts`

**C√≥digo Problem√°tico:**
```typescript
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);
```

**Corre√ß√£o:**
```typescript
import { SupabaseService } from '@/modules/common/services/SupabaseService';

const supabase = SupabaseService.getInstance().getAdminClient();
```

**Checklist:**
- [ ] Substituir `createClient` direto por `SupabaseService`
- [ ] Remover imports de `@supabase/supabase-js`
- [ ] Verificar se n√£o h√° outras inst√¢ncias hardcoded
- [ ] Testar funcionalidade

---

### 1.3 Adicionar Valida√ß√£o B√°sica com Zod

**Criar Schemas de Valida√ß√£o:**

```typescript
// app/api/partner/checklist/lib/schemas.ts
import { z } from 'zod';

export const LoadChecklistSchema = z.object({
  inspection_id: z.string().uuid('inspection_id inv√°lido'),
  vehicle_id: z.string().uuid('vehicle_id inv√°lido'),
});

export const SaveAnomaliesSchema = z.object({
  inspection_id: z.string().uuid('inspection_id inv√°lido'),
  vehicle_id: z.string().uuid('vehicle_id inv√°lido'),
  anomalies: z.array(z.object({
    description: z.string().min(1, 'Descri√ß√£o √© obrigat√≥ria'),
    photos: z.array(z.string()).optional(),
  })),
});

export const ExistsChecklistSchema = z.object({
  quoteId: z.string().uuid('quoteId inv√°lido'),
});
```

**Aplicar nos Endpoints:**
```typescript
// Exemplo: checklist/load/route.ts
import { LoadChecklistSchema } from '../lib/schemas';

async function loadChecklistHandler(req: AuthenticatedRequest) {
  const body = await req.json();
  
  // Valida√ß√£o
  const validation = LoadChecklistSchema.safeParse(body);
  if (!validation.success) {
    return NextResponse.json(
      { success: false, errors: validation.error.errors },
      { status: 400 }
    );
  }
  
  const { inspection_id, vehicle_id } = validation.data;
  // ... resto da l√≥gica
}
```

**Checklist:**
- [ ] Criar pasta `app/api/partner/checklist/lib/`
- [ ] Criar arquivo `schemas.ts` com todos os schemas
- [ ] Aplicar valida√ß√£o em `load/route.ts`
- [ ] Aplicar valida√ß√£o em `load-anomalies/route.ts`
- [ ] Aplicar valida√ß√£o em `exists/route.ts`
- [ ] Aplicar valida√ß√£o em `save-anomalies/route.ts`
- [ ] Testar com dados inv√°lidos
- [ ] Testar com dados v√°lidos

---

## üìÖ Fase 2: Padroniza√ß√£o de Infraestrutura (P1)

**Dura√ß√£o Estimada:** 4-6 horas  
**Branch:** `refactor/partner-standardization`

### 2.1 Padronizar Cliente Supabase

**Objetivo:** Usar APENAS `SupabaseService` em todos os endpoints

**Arquivos para Modificar:**
- `checklist/save-anomalies/route.ts`
- `checklist/upload-evidence/route.ts`
- `checklist/load/route.ts`
- `checklist/submit/route.ts`
- `checklist/init/route.ts`
- `quotes/send-to-admin/route.ts`

**Padr√£o de Substitui√ß√£o:**
```typescript
// REMOVER
import { createApiClient } from '@/lib/supabase/api';
const supabase = createApiClient();

// ADICIONAR
import { SupabaseService } from '@/modules/common/services/SupabaseService';
const supabase = SupabaseService.getInstance().getAdminClient();
```

**Checklist:**
- [ ] Criar script de busca e substitui√ß√£o
- [ ] Executar substitui√ß√£o em cada arquivo
- [ ] Remover imports n√£o utilizados
- [ ] Testar cada endpoint modificado
- [ ] Verificar se n√£o quebrou nenhum teste
- [ ] Commit: "refactor(partner): padroniza uso de SupabaseService"

---

### 2.2 Remover Autentica√ß√£o Manual

**Objetivo:** Usar APENAS `withPartnerAuth` middleware

**Arquivos para Modificar:**
- `checklist/save-anomalies/route.ts` (linhas 64-82)
- `checklist/upload-evidence/route.ts` (linhas 23-25)
- `checklist/submit/route.ts` (linhas 212-228)

**Padr√£o de Refatora√ß√£o:**

**ANTES:**
```typescript
export async function POST(request: Request) {
  const authHeader = request.headers.get('authorization') || request.headers.get('Authorization');
  const token = authHeader?.startsWith('Bearer ')
    ? authHeader.substring('Bearer '.length)
    : undefined;

  let partnerId: string | undefined;
  if (token) {
    const { data: userData } = await supabase.auth.getUser(token);
    partnerId = userData.user?.id;
  }
  if (!partnerId) {
    return NextResponse.json(
      { success: false, error: 'Usu√°rio n√£o autenticado' },
      { status: 401 }
    );
  }
  
  // ... resto da l√≥gica usando partnerId
}
```

**DEPOIS:**
```typescript
import { withPartnerAuth, type AuthenticatedRequest } from '@/modules/common/utils/authMiddleware';

async function handler(req: AuthenticatedRequest) {
  const partnerId = req.user.id; // Dispon√≠vel diretamente
  
  // ... resto da l√≥gica
}

export const POST = withPartnerAuth(handler);
```

**Checklist:**
- [ ] Refatorar `save-anomalies/route.ts`
- [ ] Refatorar `upload-evidence/route.ts`
- [ ] Refatorar `submit/route.ts`
- [ ] Remover c√≥digo de autentica√ß√£o manual
- [ ] Testar autentica√ß√£o com token v√°lido
- [ ] Testar sem token (deve retornar 401)
- [ ] Commit: "refactor(partner): usa withPartnerAuth em todos endpoints"

---

### 2.3 Deprecar Endpoints v1 de Servi√ßos

**Objetivo:** Manter apenas v2, remover v1

**An√°lise de Uso:**
```bash
# Buscar uso de v1 no frontend
grep -r "/api/partner/services" app/ modules/ --exclude-dir=node_modules
```

**Estrat√©gia:**
1. Identificar todos os consumidores de v1
2. Migrar consumidores para v2
3. Adicionar deprecation notice em v1
4. Ap√≥s 1 semana, remover v1

**Arquivos v1 para Remover (depois da migra√ß√£o):**
- `app/api/partner/services/route.ts`
- `app/api/partner/services/[serviceId]/route.ts`

**Migration Guide para Frontend:**
```typescript
// ANTES (v1)
const response = await fetch('/api/partner/services', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ name, description, price, category }),
});

// DEPOIS (v2)
const response = await fetch('/api/partner/services/v2', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ name, description, price, category }),
});
```

**Checklist:**
- [ ] Identificar todos os consumidores de v1
- [ ] Criar lista de arquivos frontend para atualizar
- [ ] Atualizar cada consumidor para v2
- [ ] Testar fluxo completo de cada feature
- [ ] Adicionar deprecation warning em v1
- [ ] Aguardar per√≠odo de migra√ß√£o
- [ ] Remover endpoints v1
- [ ] Commit: "feat(partner): migra servi√ßos de v1 para v2"

---

## üìÖ Fase 3: Refatora√ß√£o de Arquitetura (P2)

**Dura√ß√£o Estimada:** 10-15 horas  
**Branch:** `refactor/partner-architecture`

### 3.1 Extrair MediaUploadService

**Objetivo:** Centralizar l√≥gica de upload de arquivos

**Estrutura:**
```
modules/partner/services/
‚îî‚îÄ‚îÄ MediaUploadService.ts
```

**Implementa√ß√£o:**
```typescript
// modules/partner/services/MediaUploadService.ts
import { SupabaseService } from '@/modules/common/services/SupabaseService';
import { getLogger } from '@/modules/logger';

const logger = getLogger('partner:media-upload');

export interface UploadResult {
  success: boolean;
  storagePath?: string;
  error?: string;
}

export interface UploadOptions {
  bucket: string;
  folder: string;
  file: File;
  maxSize?: number; // em bytes
  allowedTypes?: string[];
}

export class MediaUploadService {
  private static instance: MediaUploadService;
  private supabase;

  private constructor() {
    this.supabase = SupabaseService.getInstance().getAdminClient();
  }

  static getInstance(): MediaUploadService {
    if (!this.instance) {
      this.instance = new MediaUploadService();
    }
    return this.instance;
  }

  /**
   * Gera nome √∫nico para arquivo
   */
  private generateFileName(originalName: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const extension = originalName.split('.').pop();
    return `${timestamp}-${random}.${extension}`;
  }

  /**
   * Valida tipo de arquivo
   */
  private validateFileType(file: File, allowedTypes: string[]): boolean {
    return allowedTypes.some(type => file.type.includes(type));
  }

  /**
   * Faz upload de arquivo √∫nico
   */
  async uploadFile(options: UploadOptions): Promise<UploadResult> {
    try {
      const { bucket, folder, file, maxSize = 5 * 1024 * 1024, allowedTypes = ['image/'] } = options;

      // Valida√ß√µes
      if (maxSize && file.size > maxSize) {
        return {
          success: false,
          error: `Arquivo muito grande. M√°ximo: ${maxSize / 1024 / 1024}MB`,
        };
      }

      if (!this.validateFileType(file, allowedTypes)) {
        return {
          success: false,
          error: `Tipo de arquivo n√£o permitido. Permitidos: ${allowedTypes.join(', ')}`,
        };
      }

      // Upload
      const fileName = this.generateFileName(file.name);
      const filePath = `${folder}/${fileName}`;

      const { error } = await this.supabase.storage
        .from(bucket)
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false,
        });

      if (error) {
        logger.error('upload_error', { error: error.message, filePath });
        return {
          success: false,
          error: 'Erro ao fazer upload do arquivo',
        };
      }

      return {
        success: true,
        storagePath: filePath,
      };
    } catch (error) {
      logger.error('upload_exception', { error: String(error) });
      return {
        success: false,
        error: 'Erro interno ao fazer upload',
      };
    }
  }

  /**
   * Faz upload de m√∫ltiplos arquivos
   */
  async uploadMultiple(
    files: File[],
    bucket: string,
    folder: string
  ): Promise<UploadResult[]> {
    const promises = files.map(file =>
      this.uploadFile({ bucket, folder, file })
    );
    return Promise.all(promises);
  }

  /**
   * Gera URL assinada para visualiza√ß√£o
   */
  async getSignedUrl(bucket: string, path: string, expiresIn: number = 3600): Promise<string | null> {
    try {
      const { data } = await this.supabase.storage
        .from(bucket)
        .createSignedUrl(path, expiresIn);
      
      return data?.signedUrl || null;
    } catch (error) {
      logger.error('signed_url_error', { error: String(error), path });
      return null;
    }
  }

  /**
   * Remove arquivo
   */
  async deleteFile(bucket: string, path: string): Promise<boolean> {
    try {
      const { error } = await this.supabase.storage
        .from(bucket)
        .remove([path]);
      
      if (error) {
        logger.error('delete_error', { error: error.message, path });
        return false;
      }
      
      return true;
    } catch (error) {
      logger.error('delete_exception', { error: String(error), path });
      return false;
    }
  }
}
```

**Uso nos Endpoints:**
```typescript
// save-anomalies/route.ts (DEPOIS)
import { MediaUploadService } from '@/modules/partner/services/MediaUploadService';

const mediaService = MediaUploadService.getInstance();

for (let j = 0; j < photos.length; j++) {
  const photoKey = `anomaly-${i}-photo-${j}`;
  const photoFile = formData.get(photoKey) as File;

  if (photoFile instanceof File) {
    const result = await mediaService.uploadFile({
      bucket: 'vehicle-media',
      folder: `anomalies/${inspection_id}/${vehicle_id}`,
      file: photoFile,
      maxSize: 5 * 1024 * 1024, // 5MB
      allowedTypes: ['image/'],
    });

    if (result.success) {
      uploadedPhotoUrls.push(result.storagePath!);
    }
  }
}
```

**Checklist:**
- [ ] Criar `MediaUploadService.ts`
- [ ] Implementar m√©todo `uploadFile`
- [ ] Implementar m√©todo `uploadMultiple`
- [ ] Implementar m√©todo `getSignedUrl`
- [ ] Implementar m√©todo `deleteFile`
- [ ] Adicionar testes unit√°rios
- [ ] Refatorar `save-anomalies/route.ts` para usar service
- [ ] Refatorar `upload-evidence/route.ts` para usar service
- [ ] Testar uploads
- [ ] Commit: "refactor(partner): cria MediaUploadService centralizado"

---

### 3.2 Criar Domain Layer para Checklist

**Objetivo:** Aplicar DDD ao contexto de Checklist

**Estrutura Proposta:**
```
modules/partner/domain/
‚îî‚îÄ‚îÄ checklist/
    ‚îú‚îÄ‚îÄ entities/
    ‚îÇ   ‚îú‚îÄ‚îÄ VehicleChecklist.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ MechanicsChecklist.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ Anomaly.ts
    ‚îú‚îÄ‚îÄ value-objects/
    ‚îÇ   ‚îú‚îÄ‚îÄ ChecklistStatus.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ FuelLevel.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ InspectionDate.ts
    ‚îú‚îÄ‚îÄ repositories/
    ‚îÇ   ‚îú‚îÄ‚îÄ IChecklistRepository.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ SupabaseChecklistRepository.ts
    ‚îî‚îÄ‚îÄ application/
        ‚îî‚îÄ‚îÄ services/
            ‚îî‚îÄ‚îÄ ChecklistApplicationService.ts
```

**Entidade Principal:**
```typescript
// entities/VehicleChecklist.ts
export class VehicleChecklist {
  constructor(
    public readonly id: string,
    public readonly vehicleId: string,
    public readonly inspectionDate: Date,
    public readonly odometer: number,
    public readonly fuelLevel: FuelLevel,
    public readonly observations: string | null,
    public readonly status: ChecklistStatus,
    public readonly finalized: boolean,
    public readonly services: InspectionService[],
    public readonly media: InspectionMedia[],
  ) {}

  /**
   * Valida se checklist pode ser finalizado
   */
  canBeFinalized(): boolean {
    return (
      !this.finalized &&
      this.odometer > 0 &&
      this.inspectionDate <= new Date()
    );
  }

  /**
   * Finaliza checklist
   */
  finalize(): VehicleChecklist {
    if (!this.canBeFinalized()) {
      throw new Error('Checklist n√£o pode ser finalizado');
    }

    return new VehicleChecklist(
      this.id,
      this.vehicleId,
      this.inspectionDate,
      this.odometer,
      this.fuelLevel,
      this.observations,
      ChecklistStatus.FINALIZED,
      true,
      this.services,
      this.media,
    );
  }

  /**
   * Adiciona servi√ßo
   */
  addService(service: InspectionService): VehicleChecklist {
    if (this.finalized) {
      throw new Error('N√£o √© poss√≠vel adicionar servi√ßo em checklist finalizado');
    }

    return new VehicleChecklist(
      this.id,
      this.vehicleId,
      this.inspectionDate,
      this.odometer,
      this.fuelLevel,
      this.observations,
      this.status,
      this.finalized,
      [...this.services, service],
      this.media,
    );
  }
}
```

**Repository Interface:**
```typescript
// repositories/IChecklistRepository.ts
export interface IChecklistRepository {
  findById(id: string): Promise<VehicleChecklist | null>;
  findByVehicleId(vehicleId: string): Promise<VehicleChecklist[]>;
  findActiveByVehicleId(vehicleId: string): Promise<VehicleChecklist | null>;
  save(checklist: VehicleChecklist): Promise<VehicleChecklist>;
  update(checklist: VehicleChecklist): Promise<VehicleChecklist>;
  delete(id: string): Promise<void>;
}
```

**Application Service:**
```typescript
// application/services/ChecklistApplicationService.ts
export class ChecklistApplicationService {
  constructor(
    private readonly repository: IChecklistRepository,
    private readonly mediaService: MediaUploadService,
  ) {}

  async createChecklist(command: CreateChecklistCommand): Promise<Result<VehicleChecklist>> {
    try {
      // Valida√ß√µes
      if (command.odometer <= 0) {
        return Result.failure('Quilometragem inv√°lida');
      }

      // Criar entidade
      const checklist = new VehicleChecklist(
        generateId(),
        command.vehicleId,
        command.inspectionDate,
        command.odometer,
        command.fuelLevel,
        command.observations,
        ChecklistStatus.DRAFT,
        false,
        [],
        [],
      );

      // Persistir
      const saved = await this.repository.save(checklist);

      return Result.success(saved);
    } catch (error) {
      return Result.failure('Erro ao criar checklist');
    }
  }

  async finalizeChecklist(id: string): Promise<Result<VehicleChecklist>> {
    // Buscar checklist
    const checklist = await this.repository.findById(id);
    if (!checklist) {
      return Result.failure('Checklist n√£o encontrado');
    }

    // Finalizar (l√≥gica de dom√≠nio)
    const finalized = checklist.finalize();

    // Persistir
    const updated = await this.repository.update(finalized);

    return Result.success(updated);
  }
}
```

**Checklist:**
- [ ] Criar estrutura de pastas
- [ ] Implementar Value Objects
- [ ] Implementar Entidades
- [ ] Implementar Repository Interface
- [ ] Implementar Supabase Repository
- [ ] Implementar Application Service
- [ ] Criar testes unit√°rios para entidades
- [ ] Criar testes de integra√ß√£o para repository
- [ ] Commit: "feat(partner): adiciona domain layer para checklist"

---

### 3.3 Unificar Endpoints de Checklist

**Objetivo:** Consolidar l√≥gica dispersa em um √∫nico Application Service

**Endpoints Atuais:**
1. `/api/partner/save-vehicle-checklist` - Checklist inicial
2. `/api/partner/checklist/submit` - Checklist mec√¢nico
3. `/api/partner/checklist/save-anomalies` - Anomalias

**Nova Estrutura Proposta:**
```
/api/partner/checklist/
‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îú‚îÄ‚îÄ route.ts (GET, PUT, DELETE)
‚îÇ   ‚îú‚îÄ‚îÄ finalize/route.ts (POST)
‚îÇ   ‚îî‚îÄ‚îÄ anomalies/route.ts (GET, POST)
‚îú‚îÄ‚îÄ route.ts (GET list, POST create)
‚îú‚îÄ‚îÄ mechanics/[id]/route.ts (GET, PUT)
‚îî‚îÄ‚îÄ upload/route.ts (POST para upload de m√≠dia)
```

**Migra√ß√£o Gradual:**
```typescript
// Novo endpoint unificado: /api/partner/checklist/route.ts
import { withPartnerAuth } from '@/modules/common/utils/authMiddleware';
import { ChecklistApplicationService } from '@/modules/partner/domain/checklist/application/services/ChecklistApplicationService';

const service = new ChecklistApplicationService(/*...*/);

// GET /api/partner/checklist - Lista checklists
async function getChecklists(req: AuthenticatedRequest) {
  const { vehicleId } = req.query;
  
  if (vehicleId) {
    const result = await service.getChecklistsByVehicle(vehicleId);
    return mapToResponse(result);
  }
  
  const result = await service.getChecklistsByPartner(req.user.id);
  return mapToResponse(result);
}

// POST /api/partner/checklist - Cria checklist
async function createChecklist(req: AuthenticatedRequest) {
  const dto = await req.json();
  const command = mapToCreateCommand(dto, req.user.id);
  const result = await service.createChecklist(command);
  return mapToResponse(result);
}

export const GET = withPartnerAuth(getChecklists);
export const POST = withPartnerAuth(createChecklist);
```

**Checklist:**
- [ ] Criar novos endpoints unificados
- [ ] Implementar GET list
- [ ] Implementar POST create
- [ ] Implementar GET by id
- [ ] Implementar PUT update
- [ ] Implementar DELETE
- [ ] Implementar POST finalize
- [ ] Implementar anomalies endpoints
- [ ] Manter endpoints antigos com deprecation notice
- [ ] Atualizar frontend para usar novos endpoints
- [ ] Testar todas as funcionalidades
- [ ] Remover endpoints antigos ap√≥s migra√ß√£o
- [ ] Commit: "refactor(partner): unifica endpoints de checklist"

---

## üìÖ Fase 4: Melhorias de Qualidade (P3)

**Dura√ß√£o Estimada:** 6-8 horas  
**Branch:** `refactor/partner-quality`

### 4.1 Criar Schemas Zod Completos

**Objetivo:** Valida√ß√£o robusta em todos os endpoints

**Estrutura:**
```
app/api/partner/
‚îú‚îÄ‚îÄ checklist/
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îÇ       ‚îî‚îÄ‚îÄ schemas.ts
‚îú‚îÄ‚îÄ budgets/
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îÇ       ‚îî‚îÄ‚îÄ schemas.ts
‚îî‚îÄ‚îÄ services/
    ‚îî‚îÄ‚îÄ v2/
        ‚îî‚îÄ‚îÄ lib/
            ‚îî‚îÄ‚îÄ schemas.ts (j√° existe)
```

**Exemplo de Schema Completo:**
```typescript
// checklist/lib/schemas.ts
import { z } from 'zod';

export const FuelLevelSchema = z.enum([
  'empty',
  'quarter',
  'half',
  'three_quarters',
  'full',
]);

export const CreateChecklistSchema = z.object({
  vehicleId: z.string().uuid('ID do ve√≠culo inv√°lido'),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Data inv√°lida (use YYYY-MM-DD)'),
  odometer: z.number().int().positive('Quilometragem deve ser positiva'),
  fuelLevel: FuelLevelSchema,
  observations: z.string().max(1000, 'Observa√ß√µes muito longas').optional(),
  services: z.object({
    mechanics: z.object({
      required: z.boolean().optional(),
      notes: z.string().max(500).optional(),
    }).optional(),
    bodyPaint: z.object({
      required: z.boolean().optional(),
      notes: z.string().max(500).optional(),
    }).optional(),
    // ... outros servi√ßos
  }).optional(),
});

export const UpdateChecklistSchema = CreateChecklistSchema.partial().extend({
  id: z.string().uuid(),
});

export const FinalizeChecklistSchema = z.object({
  id: z.string().uuid(),
});
```

**Checklist:**
- [ ] Criar schemas para Checklist
- [ ] Criar schemas para Budgets
- [ ] Criar schemas para Anomalias
- [ ] Aplicar valida√ß√£o em todos os endpoints
- [ ] Adicionar mensagens de erro amig√°veis
- [ ] Testar com dados inv√°lidos
- [ ] Commit: "feat(partner): adiciona valida√ß√£o Zod completa"

---

### 4.2 Melhorar Tratamento de Erros

**Objetivo:** Erros consistentes e informativos

**Hierarquia de Exce√ß√µes:**
```typescript
// modules/common/errors/index.ts
export class AppError extends Error {
  constructor(
    public readonly message: string,
    public readonly code: string,
    public readonly statusCode: number,
    public readonly details?: unknown,
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 'VALIDATION_ERROR', 400, details);
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'N√£o autenticado') {
    super(message, 'AUTHENTICATION_ERROR', 401);
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = 'Sem permiss√£o') {
    super(message, 'AUTHORIZATION_ERROR', 403);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} n√£o encontrado`, 'NOT_FOUND', 404);
  }
}

export class BusinessRuleError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 'BUSINESS_RULE_ERROR', 422, details);
  }
}

export class InfrastructureError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 'INFRASTRUCTURE_ERROR', 500, details);
  }
}
```

**Error Handler Centralizado:**
```typescript
// modules/common/utils/errorHandler.ts
import { NextResponse } from 'next/server';
import { AppError } from '../errors';
import { getLogger } from '@/modules/logger';

const logger = getLogger('error-handler');

export function handleError(error: unknown): NextResponse {
  // AppError customizado
  if (error instanceof AppError) {
    logger.warn('app_error', {
      code: error.code,
      message: error.message,
      statusCode: error.statusCode,
      details: error.details,
    });

    return NextResponse.json(
      {
        success: false,
        error: {
          code: error.code,
          message: error.message,
          details: error.details,
        },
      },
      { status: error.statusCode }
    );
  }

  // Erro desconhecido
  logger.error('unhandled_error', {
    error: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
  });

  return NextResponse.json(
    {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Erro interno do servidor',
      },
    },
    { status: 500 }
  );
}
```

**Uso nos Endpoints:**
```typescript
import { handleError } from '@/modules/common/utils/errorHandler';
import { NotFoundError, ValidationError } from '@/modules/common/errors';

async function handler(req: AuthenticatedRequest) {
  try {
    const checklist = await repository.findById(id);
    
    if (!checklist) {
      throw new NotFoundError('Checklist');
    }
    
    if (!checklist.canBeFinalized()) {
      throw new BusinessRuleError('Checklist n√£o pode ser finalizado');
    }
    
    // ... l√≥gica
    
    return NextResponse.json({ success: true, data: checklist });
  } catch (error) {
    return handleError(error);
  }
}
```

**Checklist:**
- [ ] Criar hierarquia de exce√ß√µes
- [ ] Criar error handler centralizado
- [ ] Refatorar todos os endpoints para usar exce√ß√µes customizadas
- [ ] Remover try-catch gen√©ricos
- [ ] Adicionar logs estruturados
- [ ] Testar diferentes tipos de erro
- [ ] Commit: "refactor(partner): melhora tratamento de erros"

---

### 4.3 Refatorar Fun√ß√µes Longas

**Objetivo:** Fun√ß√µes menores, mais leg√≠veis e test√°veis

**Princ√≠pios:**
- M√°ximo 20 linhas por fun√ß√£o
- M√°ximo 3 n√≠veis de indenta√ß√£o
- Uma responsabilidade por fun√ß√£o

**Exemplo: Refatorar `checklist/submit/route.ts` (344 linhas)**

**ANTES:**
```typescript
export async function PUT(request: Request) {
  try {
    const checklistData = await request.json();
    
    // 50 linhas de valida√ß√£o
    // 100 linhas de mapeamento
    // 50 linhas de persist√™ncia
    // 50 linhas de l√≥gica adicional
    
    return NextResponse.json({ success: true });
  } catch (e) {
    return NextResponse.json({ error: 'Erro' }, { status: 500 });
  }
}
```

**DEPOIS:**
```typescript
// Quebrar em fun√ß√µes menores
async function validateChecklistData(data: unknown): ChecklistData {
  // valida√ß√£o
}

async function mapChecklistToEntities(data: ChecklistData): MechanicsChecklist {
  // mapeamento
}

async function persistChecklist(checklist: MechanicsChecklist): void {
  // persist√™ncia
}

async function recordChecklistHistory(checklistId: string): void {
  // hist√≥rico
}

// Handler principal fica pequeno
async function submitChecklistHandler(req: AuthenticatedRequest) {
  try {
    const data = await validateChecklistData(await req.json());
    const checklist = await mapChecklistToEntities(data);
    await persistChecklist(checklist);
    await recordChecklistHistory(checklist.id);
    
    return NextResponse.json({ success: true, data: checklist });
  } catch (error) {
    return handleError(error);
  }
}
```

**Arquivos Priorit√°rios:**
- `checklist/submit/route.ts` (344 linhas)
- `save-vehicle-checklist/route.ts` (292 linhas)
- `save-anomalies/route.ts` (244 linhas)
- `budgets/[budgetId]/route.ts`

**Checklist:**
- [ ] Identificar fun√ß√µes com mais de 50 linhas
- [ ] Quebrar em fun√ß√µes menores
- [ ] Extrair l√≥gica de neg√≥cio para services
- [ ] Adicionar testes unit√°rios
- [ ] Verificar legibilidade
- [ ] Commit: "refactor(partner): quebra fun√ß√µes longas"

---

## üìä M√©tricas de Sucesso

### Antes da Refatora√ß√£o
- üî¥ **19 endpoints** com padr√µes inconsistentes
- üî¥ **6 endpoints** sem autentica√ß√£o adequada
- üî¥ **3 formas diferentes** de criar cliente Supabase
- üî¥ **Autentica√ß√£o manual** duplicada em 6+ arquivos
- üî¥ **L√≥gica de upload** duplicada em 2 arquivos
- üî¥ **Sem Domain Layer** (exceto v2 services)
- üî¥ **Fun√ß√µes grandes** (100-344 linhas)

### Depois da Refatora√ß√£o
- ‚úÖ **19 endpoints** com padr√£o √∫nico
- ‚úÖ **Todos endpoints** protegidos com `withPartnerAuth`
- ‚úÖ **Uma forma** de criar cliente (`SupabaseService`)
- ‚úÖ **Zero duplica√ß√£o** de autentica√ß√£o
- ‚úÖ **MediaUploadService** centralizado
- ‚úÖ **Domain Layer completo** para Checklist
- ‚úÖ **Fun√ß√µes pequenas** (< 30 linhas)
- ‚úÖ **Valida√ß√£o Zod** em todos os endpoints
- ‚úÖ **Error handling** consistente

---

## üöÄ Como Executar

### Pr√©-requisitos
- Branch limpa (commit ou stash de mudan√ßas pendentes)
- Testes passando na branch atual
- Backup do banco de dados

### Executar Fase 1 (Seguran√ßa)
```bash
# Criar branch
git checkout -b refactor/partner-security-fixes

# Fazer mudan√ßas...

# Testar
npm run test:partner

# Commit
git add .
git commit -m "fix(partner): adiciona autentica√ß√£o em endpoints desprotegidos"

# Push
git push origin refactor/partner-security-fixes

# Criar PR
```

### Executar Fase 2 (Padroniza√ß√£o)
```bash
# Criar branch
git checkout -b refactor/partner-standardization

# ... repetir processo
```

---

## üìù Notas Importantes

### Retrocompatibilidade
- **Manter endpoints antigos** durante migra√ß√£o
- **Adicionar deprecation notice** antes de remover
- **Per√≠odo de transi√ß√£o:** m√≠nimo 1 semana
- **Comunicar mudan√ßas** ao time

### Testes
- **Testar cada mudan√ßa** antes de commit
- **Manter coverage** acima de 80%
- **Adicionar testes de integra√ß√£o** para novos services
- **N√£o quebrar testes existentes**

### Documenta√ß√£o
- **Atualizar docs** conforme mudan√ßas
- **Documentar breaking changes**
- **Criar migration guides**
- **Atualizar README**

---

## üîó Documentos Relacionados

- [01-ANALYSIS.md](./01-ANALYSIS.md) - An√°lise completa de inconsist√™ncias
- [03-MIGRATION-GUIDE.md](./03-MIGRATION-GUIDE.md) - Guia de migra√ß√£o para frontend
- [04-TESTING-PLAN.md](./04-TESTING-PLAN.md) - Plano de testes
