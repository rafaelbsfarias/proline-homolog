/**
 * Script de Verifica√ß√£o Completa do Estado do Banco de Dados
 * Testa collections, vehicles, history, triggers e gera relat√≥rio detalhado
 * Vers√£o PostgreSQL Direto (Corrigida)
 */

import pkg from 'pg';
const { Client } = pkg;
import { writeFileSync } from 'fs';
import { join } from 'path';

const DB_CONFIG = {
  host: '127.0.0.1',
  port: 54322,
  database: 'postgres',
  user: 'postgres',
  password: 'postgres',
};

class DatabaseTester {
  constructor() {
    this.client = new Client(DB_CONFIG);
    this.report = {
      timestamp: new Date().toISOString(),
      summary: {},
      details: {},
      issues: [],
      recommendations: [],
    };
  }

  async connect() {
    try {
      await this.client.connect();
      console.log('‚úÖ Conectado ao PostgreSQL');
    } catch (error) {
      console.error('‚ùå Erro ao conectar:', error.message);
      throw error;
    }
  }

  async disconnect() {
    await this.client.end();
    console.log('üîå Conex√£o fechada');
  }

  async runAllTests() {
    console.log('üöÄ INICIANDO TESTES COMPLETOS DO BANCO DE DADOS');
    console.log('='.repeat(80));

    try {
      await this.connect();

      await this.testTableStructures();
      await this.testCollectionsState();
      await this.testVehiclesState();
      await this.testHistoryState();
      await this.testTriggersAndFunctions();
      await this.testAuditLogs();
      await this.testDataConsistency();
      await this.generateReport();

      console.log('\n‚úÖ TODOS OS TESTES CONCLU√çDOS!');
      console.log('üìÑ Relat√≥rio salvo em: reports/database-test-report.json');
    } catch (error) {
      console.error('üí• ERRO CR√çTICO NOS TESTES:', error);
      this.report.issues.push(`Erro cr√≠tico: ${error.message}`);
    } finally {
      await this.disconnect();
    }
  }

  async testTableStructures() {
    console.log('\nüîç TESTANDO ESTRUTURAS DAS TABELAS');
    console.log('-'.repeat(50));

    const tables = [
      'vehicle_collections',
      'collection_history',
      'vehicles',
      'audit_logs',
      'profiles',
    ];

    for (const table of tables) {
      try {
        const result = await this.client.query(`SELECT COUNT(*) as count FROM ${table} LIMIT 1`);
        console.log(`‚úÖ Tabela ${table}: OK (${result.rows[0].count} registros)`);
      } catch (error) {
        console.log(`‚ùå Tabela ${table}: ERRO - ${error.message}`);
        this.report.issues.push(`Tabela ${table} inacess√≠vel: ${error.message}`);
      }
    }
  }

  async testCollectionsState() {
    console.log('\nüì¶ ANALISANDO ESTADO DAS COLLECTIONS');
    console.log('-'.repeat(50));

    let collections = [];
    let statusStats = {};
    let orphanedCollections = [];

    try {
      const result = await this.client.query(`
        SELECT
          vc.id,
          vc.status,
          vc.collection_date,
          vc.created_at,
          vc.updated_at,
          COUNT(v.id) as vehicle_count
        FROM vehicle_collections vc
        LEFT JOIN vehicles v ON vc.id = v.collection_id
        GROUP BY vc.id, vc.status, vc.collection_date, vc.created_at, vc.updated_at
        ORDER BY vc.updated_at DESC
      `);

      collections = result.rows;
      const total = collections.length;
      console.log(`üìä Total de collections: ${total}`);

      if (total > 0) {
        // Estat√≠sticas por status
        statusStats = collections.reduce((acc, coll) => {
          acc[coll.status] = (acc[coll.status] || 0) + 1;
          return acc;
        }, {});

        console.log('\nüìà Estat√≠sticas por status:');
        Object.entries(statusStats).forEach(([status, count]) => {
          console.log(`   ${status}: ${count}`);
        });

        // Verificar collections √≥rf√£s (sem ve√≠culos associados)
        orphanedCollections = collections.filter(coll => parseInt(coll.vehicle_count) === 0);
        if (orphanedCollections.length > 0) {
          console.log(`\n‚ö†Ô∏è  Collections √≥rf√£s encontradas: ${orphanedCollections.length}`);
          this.report.issues.push(
            `${orphanedCollections.length} collections sem ve√≠culos associados`
          );
          orphanedCollections.slice(0, 3).forEach(coll => {
            console.log(
              `   ID: ${coll.id.slice(0, 8)}... | Status: ${coll.status} | Data: ${coll.collection_date}`
            );
          });
        }

        // √öltimas 5 collections atualizadas
        console.log('\nüïê √öltimas 5 collections atualizadas:');
        collections.slice(0, 5).forEach((coll, index) => {
          console.log(
            `   ${index + 1}. ${coll.collection_date} | ${coll.status} | ${coll.vehicle_count} ve√≠culo(s) | ID: ${coll.id.slice(0, 8)}...`
          );
        });
      }
    } catch (error) {
      console.log(`‚ùå Erro ao analisar collections: ${error.message}`);
      this.report.issues.push(`Erro na an√°lise de collections: ${error.message}`);
    }

    this.report.details.collections = {
      total: collections.length,
      statusStats,
      orphanedCount: orphanedCollections.length,
      recent: collections.slice(0, 5),
    };
  }

  async testVehiclesState() {
    console.log('\nüöó ANALISANDO ESTADO DOS VE√çCULOS');
    console.log('-'.repeat(50));

    let vehicles = [];
    let statusStats = {};
    let vehiclesWithCollections = [];
    let vehiclesWithoutCollections = [];
    let dateChangeRequests = [];

    try {
      const result = await this.client.query(`
        SELECT
          v.id,
          v.plate,
          v.status,
          v.estimated_arrival_date,
          v.collection_id,
          v.created_at,
          vc.status as collection_status,
          vc.collection_date
        FROM vehicles v
        LEFT JOIN vehicle_collections vc ON v.collection_id = vc.id
        ORDER BY v.created_at DESC
      `);

      vehicles = result.rows;
      const total = vehicles.length;
      console.log(`üìä Total de ve√≠culos: ${total}`);

      if (total > 0) {
        // Estat√≠sticas por status
        statusStats = vehicles.reduce((acc, veh) => {
          acc[veh.status] = (acc[veh.status] || 0) + 1;
          return acc;
        }, {});

        console.log('\nüìà Estat√≠sticas por status:');
        Object.entries(statusStats).forEach(([status, count]) => {
          console.log(`   ${status}: ${count}`);
        });

        // Verificar ve√≠culos com collections
        vehiclesWithCollections = vehicles.filter(v => v.collection_id);
        vehiclesWithoutCollections = vehicles.filter(v => !v.collection_id);

        console.log(`\nüîó Ve√≠culos com collections: ${vehiclesWithCollections.length}`);
        console.log(`üö´ Ve√≠culos sem collections: ${vehiclesWithoutCollections.length}`);

        // Verificar inconsist√™ncias de status
        const inconsistentVehicles = vehicles.filter(
          v =>
            v.collection_id &&
            v.collection_status === 'requested' &&
            v.status !== 'AGUARDANDO APROVA√á√ÉO DA COLETA' &&
            v.status !== 'SOLICITA√á√ÉO DE MUDAN√áA DE DATA'
        );

        if (inconsistentVehicles.length > 0) {
          console.log(`\n‚ö†Ô∏è  Ve√≠culos com status inconsistente: ${inconsistentVehicles.length}`);
          this.report.issues.push(
            `${inconsistentVehicles.length} ve√≠culos com status inconsistente entre vehicle e collection`
          );
        }

        // Ve√≠culos com solicita√ß√£o de mudan√ßa de data
        dateChangeRequests = vehicles.filter(v => v.status === 'SOLICITA√á√ÉO DE MUDAN√áA DE DATA');
        if (dateChangeRequests.length > 0) {
          console.log(`\nüìÖ Solicita√ß√µes de mudan√ßa de data: ${dateChangeRequests.length}`);
          dateChangeRequests.forEach(veh => {
            console.log(`   ${veh.plate}: ${veh.estimated_arrival_date}`);
          });
        }
      }
    } catch (error) {
      console.log(`‚ùå Erro ao analisar ve√≠culos: ${error.message}`);
      this.report.issues.push(`Erro na an√°lise de ve√≠culos: ${error.message}`);
    }

    this.report.details.vehicles = {
      total: vehicles.length,
      statusStats,
      withCollections: vehiclesWithCollections.length,
      withoutCollections: vehiclesWithoutCollections.length,
      dateChangeRequests: dateChangeRequests.length,
    };
  }

  async testHistoryState() {
    console.log('\nüìö ANALISANDO HIST√ìRICO DE COLLECTIONS');
    console.log('-'.repeat(50));

    let history = [];
    let totalRevenue = 0;
    let totalVehicles = 0;
    let avgRevenue = 0;
    let avgVehicles = 0;

    try {
      const result = await this.client.query(`
        SELECT * FROM collection_history
        ORDER BY created_at DESC
      `);

      history = result.rows;
      const total = history.length;
      console.log(`üìä Total de registros hist√≥ricos: ${total}`);

      if (total > 0) {
        // Estat√≠sticas gerais
        totalRevenue = history.reduce((sum, h) => sum + (parseFloat(h.total_amount) || 0), 0);
        totalVehicles = history.reduce((sum, h) => sum + (parseInt(h.vehicle_count) || 0), 0);

        console.log(
          `üí∞ Receita total hist√≥rica: R$ ${totalRevenue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
        );
        console.log(`üöó Total de ve√≠culos coletados: ${totalVehicles}`);

        avgRevenue = total > 0 ? (totalRevenue / total).toFixed(2) : 0;
        avgVehicles = total > 0 ? (totalVehicles / total).toFixed(1) : 0;

        console.log(`üìà Receita m√©dia por coleta: R$ ${avgRevenue}`);
        console.log(`üìà M√©dia de ve√≠culos por coleta: ${avgVehicles}`);

        // √öltimas 5 coletas finalizadas
        console.log('\nüïê √öltimas 5 coletas finalizadas:');
        history.slice(0, 5).forEach((hist, index) => {
          console.log(
            `   ${index + 1}. ${hist.collection_date} | ${hist.vehicle_count} ve√≠culos | R$ ${(parseFloat(hist.total_amount) || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
          );
        });
      }
    } catch (error) {
      console.log(`‚ùå Erro ao analisar hist√≥rico: ${error.message}`);
      this.report.issues.push(`Erro na an√°lise do hist√≥rico: ${error.message}`);
    }

    this.report.details.history = {
      total: history.length,
      totalRevenue,
      totalVehicles,
      avgRevenue,
      avgVehicles,
      recent: history.slice(0, 5),
    };
  }

  async testTriggersAndFunctions() {
    console.log('\n‚öôÔ∏è  VERIFICANDO TRIGGERS E FUNCTIONS');
    console.log('-'.repeat(50));

    try {
      // Verificar triggers
      const triggersResult = await this.client.query(`
        SELECT trigger_name, event_manipulation, event_object_table, action_statement
        FROM information_schema.triggers
        ORDER BY event_object_table
      `);

      const triggers = triggersResult.rows;
      console.log(`üìä Total de triggers encontrados: ${triggers.length}`);

      if (triggers.length > 0) {
        console.log('\nüîß Triggers ativos:');
        triggers.forEach(trigger => {
          console.log(
            `   ${trigger.trigger_name}: ${trigger.event_manipulation} on ${trigger.event_object_table}`
          );
        });
      }

      // Verificar functions
      const functionsResult = await this.client.query(`
        SELECT routine_name, routine_type
        FROM information_schema.routines
        WHERE routine_schema = 'public' AND routine_type = 'FUNCTION'
        ORDER BY routine_name
      `);

      const functions = functionsResult.rows;
      console.log(`\nüîß Total de functions encontradas: ${functions.length}`);

      if (functions.length > 0) {
        console.log('\nFunctions dispon√≠veis:');
        functions.slice(0, 5).forEach(func => {
          console.log(`   ${func.routine_name}`);
        });
        if (functions.length > 5) {
          console.log(`   ... e mais ${functions.length - 5} functions`);
        }
      }

      this.report.details.triggers = {
        total: triggers.length,
        list: triggers,
        functions: functions.length,
      };
    } catch (error) {
      console.log(`‚ùå Erro ao verificar triggers: ${error.message}`);
      this.report.issues.push(`Erro na verifica√ß√£o de triggers: ${error.message}`);
    }
  }

  async testAuditLogs() {
    console.log('\nüìã VERIFICANDO AUDIT LOGS');
    console.log('-'.repeat(50));

    try {
      const result = await this.client.query(`
        SELECT timestamp, action, resource_type, details
        FROM audit_logs
        ORDER BY timestamp DESC
        LIMIT 10
      `);

      const logs = result.rows;
      const total = logs.length;
      console.log(`üìä Total de logs recentes: ${total}`);

      if (total > 0) {
        console.log('\nüïê √öltimos 10 logs:');
        logs.forEach((log, index) => {
          console.log(
            `   ${index + 1}. [${log.timestamp}] ${log.action} ${log.resource_type}: ${log.details?.slice(0, 50)}...`
          );
        });
      } else {
        console.log('‚ÑπÔ∏è  Nenhum log de auditoria encontrado');
        this.report.issues.push('Sistema de audit logs n√£o est√° registrando atividades');
      }

      this.report.details.auditLogs = {
        total,
        recent: logs,
      };
    } catch (error) {
      console.log(`‚ùå Erro ao verificar audit logs: ${error.message}`);
      this.report.issues.push(`Erro nos audit logs: ${error.message}`);
    }
  }

  async testDataConsistency() {
    console.log('\nüîç VERIFICANDO CONSIST√äNCIA DOS DADOS');
    console.log('-'.repeat(50));

    try {
      // Verificar se todos os ve√≠culos com collection_id t√™m uma collection v√°lida
      const orphanedResult = await this.client.query(`
        SELECT v.plate, v.collection_id
        FROM vehicles v
        LEFT JOIN vehicle_collections vc ON v.collection_id = vc.id
        WHERE v.collection_id IS NOT NULL AND vc.id IS NULL
      `);

      const orphanedVehicles = orphanedResult.rows;

      if (orphanedVehicles.length > 0) {
        console.log(`‚ö†Ô∏è  Ve√≠culos √≥rf√£os (collection_id inv√°lido): ${orphanedVehicles.length}`);
        this.report.issues.push(`${orphanedVehicles.length} ve√≠culos com collection_id inv√°lido`);
        orphanedVehicles.forEach(v => {
          console.log(`   ${v.plate}: collection_id ${v.collection_id} n√£o existe`);
        });
      } else {
        console.log('‚úÖ Todos os ve√≠culos t√™m collections v√°lidas');
      }

      // Verificar collections sem ve√≠culos
      const unusedResult = await this.client.query(`
        SELECT vc.id, vc.status, vc.collection_date
        FROM vehicle_collections vc
        LEFT JOIN vehicles v ON vc.id = v.collection_id
        WHERE v.collection_id IS NULL
      `);

      const unusedCollections = unusedResult.rows;

      if (unusedCollections.length > 0) {
        console.log(`‚ÑπÔ∏è  Collections n√£o utilizadas: ${unusedCollections.length}`);
        console.log('   (Isso pode ser normal para collections rec√©m-criadas)');
      }

      // Verificar dados espec√≠ficos da mudan√ßa de data
      const dateChangeResult = await this.client.query(`
        SELECT plate, status, estimated_arrival_date, collection_id
        FROM vehicles
        WHERE status = 'SOLICITA√á√ÉO DE MUDAN√áA DE DATA'
      `);

      const dateChangeVehicles = dateChangeResult.rows;

      if (dateChangeVehicles.length > 0) {
        console.log(
          `\nüìÖ Ve√≠culos com solicita√ß√£o de mudan√ßa de data: ${dateChangeVehicles.length}`
        );
        dateChangeVehicles.forEach(v => {
          console.log(
            `   ${v.plate}: ${v.estimated_arrival_date} (Collection: ${v.collection_id?.slice(0, 8)}...)`
          );
        });
      }
    } catch (error) {
      console.log(`‚ùå Erro na verifica√ß√£o de consist√™ncia: ${error.message}`);
      this.report.issues.push(`Erro na verifica√ß√£o de consist√™ncia: ${error.message}`);
    }
  }

  generateReport() {
    console.log('\nüìÑ GERANDO RELAT√ìRIO FINAL');
    console.log('-'.repeat(50));

    // Calcular estat√≠sticas gerais
    const summary = {
      totalCollections: this.report.details.collections?.total || 0,
      totalVehicles: this.report.details.vehicles?.total || 0,
      totalHistory: this.report.details.history?.total || 0,
      totalRevenue: this.report.details.history?.totalRevenue || 0,
      issuesCount: this.report.issues.length,
      orphanedCollections: this.report.details.collections?.orphanedCount || 0,
      dateChangeRequests: this.report.details.vehicles?.dateChangeRequests || 0,
    };

    this.report.summary = summary;

    // Gerar recomenda√ß√µes baseadas nos problemas encontrados
    if (summary.orphanedCollections > 0) {
      this.report.recommendations.push(
        'Limpar collections √≥rf√£s que n√£o est√£o associadas a ve√≠culos'
      );
    }

    if (summary.issuesCount > 0) {
      this.report.recommendations.push('Revisar e corrigir os problemas identificados');
    }

    if (summary.dateChangeRequests > 0) {
      this.report.recommendations.push('Processar solicita√ß√µes pendentes de mudan√ßa de data');
    }

    // Salvar relat√≥rio
    const reportPath = join(process.cwd(), 'reports', 'database-test-report.json');
    writeFileSync(reportPath, JSON.stringify(this.report, null, 2));

    // Exibir resumo no console
    console.log('\nüìä RESUMO EXECUTIVO:');
    console.log('='.repeat(50));
    console.log(`üì¶ Collections ativas: ${summary.totalCollections}`);
    console.log(`üöó Total de ve√≠culos: ${summary.totalVehicles}`);
    console.log(`üìö Registros hist√≥ricos: ${summary.totalHistory}`);
    console.log(
      `üí∞ Receita total: R$ ${summary.totalRevenue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`
    );
    console.log(`‚ö†Ô∏è  Problemas identificados: ${summary.issuesCount}`);
    console.log(`üîó Collections √≥rf√£s: ${summary.orphanedCollections}`);
    console.log(`üìÖ Solicita√ß√µes de mudan√ßa: ${summary.dateChangeRequests}`);

    if (this.report.issues.length > 0) {
      console.log('\nüö® PROBLEMAS IDENTIFICADOS:');
      this.report.issues.forEach((issue, index) => {
        console.log(`   ${index + 1}. ${issue}`);
      });
    }

    if (this.report.recommendations.length > 0) {
      console.log('\nüí° RECOMENDA√á√ïES:');
      this.report.recommendations.forEach((rec, index) => {
        console.log(`   ${index + 1}. ${rec}`);
      });
    }
  }
}

// Executar testes
const tester = new DatabaseTester();
tester
  .runAllTests()
  .then(() => {
    console.log('\nüéâ TESTES FINALIZADOS COM SUCESSO!');
    process.exit(0);
  })
  .catch(error => {
    console.error('üí• ERRO FATAL:', error);
    process.exit(1);
  });
